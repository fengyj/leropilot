"""
Feetech SCS servo driver implementation.

Supports Feetech STS3215 and SCS0009 servos using raw serial communication.
Directly implements SCS protocol without external SDK dependencies.
"""

import logging
import time
from typing import List, Dict, Optional

import serial

from leropilot.models.hardware import MotorInfo, MotorTelemetry, MotorBrand
from leropilot.services.hardware.drivers.base import BaseMotorDriver

logger = logging.getLogger(__name__)

# Feetech SCS protocol register addresses (STS3215)
ADDR_MODEL_NUMBER = 3
ADDR_FIRMWARE_VERSION = 3
ADDR_ID = 5
ADDR_BAUD_RATE = 6
ADDR_TORQUE_ENABLE = 40
ADDR_GOAL_POSITION = 42
ADDR_GOAL_SPEED = 46
ADDR_PRESENT_POSITION = 56
ADDR_PRESENT_SPEED = 58
ADDR_PRESENT_LOAD = 60
ADDR_PRESENT_VOLTAGE = 62
ADDR_PRESENT_TEMPERATURE = 55
ADDR_PRESENT_CURRENT = 69

# Protocol settings
PROTOCOL_END = 0  # Little-endian

# Model number mappings
MODEL_NAMES = {
    0x0E: "SCS0009",
    0x00: "STS3215",
    # Additional mappings from PoC
    1536: "SCS09",
    1792: "SCS15",
    2048: "SCS20",
    2560: "SCS25",
    3072: "SCS30",
    3584: "SCS35",
    4096: "SCS40",
    777: "STS3032",
    1545: "STS3215",
    2313: "STS3250",
}


class FeetechDriver(BaseMotorDriver):
    """Driver for Feetech SCS servo motors using official SDK"""

    def __init__(self, interface: str, baud_rate: int = 1000000):
        """
        Initialize Feetech driver.

        Args:
            interface: Serial port (e.g., "COM11", "/dev/ttyUSB0")
            baud_rate: Serial baud rate (default: 1000000)

        Raises:
            ImportError: If scservo_sdk is not installed
        """
        if not SDK_AVAILABLE:
            raise ImportError(
                "feetech-servo-sdk not installed. Install via: uv add feetech-servo-sdk"
            )

        super().__init__(interface, baud_rate)
        self.port_handler: Optional[PortHandler] = None
        self.packet_handler: Optional[PacketHandler] = None

    def connect(self) -> bool:
        """Connect to motor bus via serial port"""
        try:
            # Initialize PortHandler and PacketHandler
            self.port_handler = PortHandler(self.interface)
            self.packet_handler = PacketHandler(PROTOCOL_END)

            # Open port
            if not self.port_handler.openPort():
                logger.error(f"Failed to open port {self.interface}")
                return False

            # Set baudrate
            if not self.port_handler.setBaudRate(self.baud_rate):
                logger.error(f"Failed to set baudrate to {self.baud_rate}")
                self.port_handler.closePort()
                return False

            self.connected = True
            logger.info(f"Connected to Feetech motor bus on {self.interface} @ {self.baud_rate} baud")
            return True

        except Exception as e:
            logger.error(f"Failed to connect to Feetech motor bus: {e}")
            self.connected = False
            return False

    def disconnect(self) -> bool:
        """Disconnect from motor bus"""
        try:
            if self.port_handler:
                self.port_handler.closePort()
            self.connected = False
            logger.info("Disconnected from Feetech motor bus")
            return True
        except Exception as e:
            logger.error(f"Error disconnecting: {e}")
            return False

    def ping_motor(self, motor_id: int) -> bool:
        """
        Ping motor to check if it exists.

        Args:
            motor_id: Motor ID (1-254)

        Returns:
            True if motor responds
        """
        if not self.connected or not self.packet_handler or not self.port_handler:
            return False

        try:
            model_number, result, error = self.packet_handler.ping(self.port_handler, motor_id)
            return result == COMM_SUCCESS
        except Exception as e:
            logger.debug(f"Ping failed for motor {motor_id}: {e}")
            return False

    def scan_motors(self, scan_range: Optional[List[int]] = None) -> List[MotorInfo]:
        """
        Scan motor bus and discover all motors.

        Args:
            scan_range: List of motor IDs to scan (default: 1-253)

        Returns:
            List of discovered motors
        """
        if scan_range is None:
            scan_range = list(range(1, 254))

        discovered = []
        logger.info(f"Scanning {len(scan_range)} motor IDs on Feetech bus")

        for motor_id in scan_range:
            if self.ping_motor(motor_id):
                try:
                    # Read model number
                    model_number, result, error = self.packet_handler.ping(
                        self.port_handler, motor_id
                    )

                    if result == COMM_SUCCESS:
                        model_name = MODEL_NAMES.get(model_number, f"Unknown-{model_number}")

                        # Read telemetry for initial values
                        telemetry = self.read_telemetry(motor_id)
                        if telemetry:
                            motor_info = MotorInfo(
                                id=motor_id,
                                brand=MotorBrand.feetech,
                                model=model_name,
                                position=int(telemetry.position),
                                current=telemetry.current,
                                voltage=telemetry.voltage,
                                temperature=telemetry.temperature,
                                firmware_version="unknown",
                            )
                            discovered.append(motor_info)
                            logger.info(f"Found motor {motor_id}: {motor_info.model}")
                except Exception as e:
                    logger.warning(f"Failed to read info for motor {motor_id}: {e}")

        logger.info(f"Scan complete: found {len(discovered)} motors")
        return discovered

    def read_telemetry(self, motor_id: int) -> Optional[MotorTelemetry]:
        """
        Read real-time telemetry from a single motor.

        Args:
            motor_id: Motor ID

        Returns:
            Motor telemetry data or None if read fails
        """
        if not self.connected or not self.packet_handler or not self.port_handler:
            return None

        try:
            # Read present position (2 bytes)
            position, result, error = self.packet_handler.read2ByteTxRx(
                self.port_handler, motor_id, ADDR_PRESENT_POSITION
            )
            if result != COMM_SUCCESS:
                logger.error(f"Failed to read position from motor {motor_id}")
                return None

            # Read present speed (2 bytes)
            speed, result, error = self.packet_handler.read2ByteTxRx(
                self.port_handler, motor_id, ADDR_PRESENT_SPEED
            )
            if result != COMM_SUCCESS:
                logger.error(f"Failed to read speed from motor {motor_id}")
                return None

            # Read present load (2 bytes)
            load, result, error = self.packet_handler.read2ByteTxRx(
                self.port_handler, motor_id, ADDR_PRESENT_LOAD
            )
            if result != COMM_SUCCESS:
                logger.error(f"Failed to read load from motor {motor_id}")
                return None

            # Read temperature (1 byte)
            temperature, result, error = self.packet_handler.read1ByteTxRx(
                self.port_handler, motor_id, ADDR_PRESENT_TEMPERATURE
            )
            if result != COMM_SUCCESS:
                logger.error(f"Failed to read temperature from motor {motor_id}")
                return None

            # Read voltage (1 byte)
            voltage, result, error = self.packet_handler.read1ByteTxRx(
                self.port_handler, motor_id, ADDR_PRESENT_VOLTAGE
            )
            if result != COMM_SUCCESS:
                logger.error(f"Failed to read voltage from motor {motor_id}")
                return None

            # Read current (2 bytes)
            current, result, error = self.packet_handler.read2ByteTxRx(
                self.port_handler, motor_id, ADDR_PRESENT_CURRENT
            )
            if result != COMM_SUCCESS:
                logger.error(f"Failed to read current from motor {motor_id}")
                return None

            # Read goal position (2 bytes)
            goal_position, result, error = self.packet_handler.read2ByteTxRx(
                self.port_handler, motor_id, ADDR_GOAL_POSITION
            )
            if result != COMM_SUCCESS:
                logger.error(f"Failed to read goal position from motor {motor_id}")
                return None

            # Determine if motor is moving (speed != 0)
            moving = abs(speed) > 0

            return MotorTelemetry(
                id=motor_id,
                position=float(position),
                velocity=float(speed),
                current=int(current),  # Keep as mA for MotorTelemetry
                load=int(load),
                temperature=int(temperature),
                voltage=float(voltage) / 10.0,  # Convert to Volts
                moving=moving,
                goal_position=float(goal_position),
            )

        except Exception as e:
            logger.error(f"Failed to read telemetry from motor {motor_id}: {e}")
            return None

    def read_bulk_telemetry(self, motor_ids: List[int]) -> Dict[int, MotorTelemetry]:
        """
        Read telemetry from multiple motors efficiently.

        Args:
            motor_ids: List of motor IDs

        Returns:
            Dict mapping motor_id -> telemetry
        """
        result = {}
        for motor_id in motor_ids:
            telemetry = self.read_telemetry(motor_id)
            if telemetry:
                result[motor_id] = telemetry
        return result

    def set_position(self, motor_id: int, position: int, speed: Optional[int] = None) -> bool:
        """
        Set motor target position.

        Args:
            motor_id: Motor ID
            position: Target position (raw servo value, typically 0-4095)
            speed: Optional movement speed (0-2047)

        Returns:
            True if command sent successfully
        """
        if not self.connected or not self.packet_handler or not self.port_handler:
            return False

        try:
            # Clamp position to valid range
            position = max(0, min(4095, position))

            # Write goal position
            result, error = self.packet_handler.write2ByteTxRx(
                self.port_handler, motor_id, ADDR_GOAL_POSITION, position
            )

            if result != COMM_SUCCESS:
                logger.error(f"Failed to set position for motor {motor_id}")
                return False

            # Set speed if provided
            if speed is not None:
                speed = max(0, min(2047, speed))
                result, error = self.packet_handler.write2ByteTxRx(
                    self.port_handler, motor_id, ADDR_GOAL_SPEED, speed
                )
                if result != COMM_SUCCESS:
                    logger.warning(f"Failed to set speed for motor {motor_id}")

            logger.debug(f"Set motor {motor_id} to position {position}, speed {speed}")
            return True

        except Exception as e:
            logger.error(f"Failed to set position for motor {motor_id}: {e}")
            return False

    def set_torque(self, motor_id: int, enabled: bool) -> bool:
        """
        Enable or disable motor torque.

        Args:
            motor_id: Motor ID
            enabled: True to enable torque, False to disable

        Returns:
            True if command sent successfully
        """
        if not self.connected or not self.packet_handler or not self.port_handler:
            return False

        try:
            value = 1 if enabled else 0
            result, error = self.packet_handler.write1ByteTxRx(
                self.port_handler, motor_id, ADDR_TORQUE_ENABLE, value
            )

            if result != COMM_SUCCESS:
                logger.error(f"Failed to set torque for motor {motor_id}")
                return False

            logger.debug(f"Set motor {motor_id} torque to {enabled}")
            return True

        except Exception as e:
            logger.error(f"Failed to set torque for motor {motor_id}: {e}")
            return False

    def reboot_motor(self, motor_id: int) -> bool:
        """
        Reboot a single motor.

        Args:
            motor_id: Motor ID

        Returns:
            True if reboot command sent
        """
        logger.warning("Feetech SDK does not support reboot command")
        return False

    def bulk_set_torque(self, motor_ids: List[int], enabled: bool) -> bool:
        """
        Set torque for multiple motors at once.

        Args:
            motor_ids: List of motor IDs
            enabled: True to enable, False to disable

        Returns:
            True if all commands sent successfully
        """
        try:
            success = True
            for motor_id in motor_ids:
                if not self.set_torque(motor_id, enabled):
                    success = False
            return success
        except Exception as e:
            logger.error(f"Failed to bulk set torque: {e}")
            return False
