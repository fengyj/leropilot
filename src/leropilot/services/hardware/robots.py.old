"""
Robots-related hardware services.

This module consolidates robot discovery (previously `discovery.py`) and
robot configuration (previously `robot_config.py`). It exposes:

- `RobotConfigService` — loading/suggesting robot definitions

This module is the canonical location for robot-related services; the older
modules (`discovery.py`, `robot_config.py`) provide deprecation shims.
"""

import importlib.resources
import json
import logging
import threading
from pathlib import Path
from importlib.abc import Traversable
from typing import TYPE_CHECKING, Any, Optional, cast, Iterator

if TYPE_CHECKING:
    from leropilot.services.hardware.motor_buses.motor_bus import MotorBus

from leropilot.exceptions import (
    ResourceConflictError,
    ResourceNotFoundError,
    ValidationError,
)
from leropilot.models.hardware import (
    DeviceCategory,
    DeviceStatus,
    MotorBusDefinition,
    MotorLimit,
    MotorModelInfo,
    Robot,
    RobotDefinition,
    RobotMotorBusConnection,
    RobotMotorDefinition,
)
from leropilot.services.hardware.platform_adapter import PlatformAdapter
from leropilot.services.i18n import get_i18n_service

logger = logging.getLogger(__name__)


# --- Path helpers for robot data directory ----------------------------------

def get_robots_base_dir(create: bool = True) -> Path:
    """Return the base directory for robot persistent data: data_dir/hardwares/robots.

    Args:
        create: When True (default), ensure the directory exists.

    Returns:
        Path pointing to the robots directory.
    """
    from leropilot.services.config.manager import get_config

    cfg = get_config()
    data_dir = Path(cfg.paths.data_dir)
    robots_dir = data_dir / "hardwares" / "robots"
    if create:
        robots_dir.mkdir(parents=True, exist_ok=True)
    return robots_dir


def get_robot_list_path() -> Path:
    """Return the expected path to the persisted robots list.json (ensures parent dir exists)."""
    robots_dir = get_robots_base_dir(create=True)
    return robots_dir / "list.json"


def get_robot_base_dir(robot_id: str, create: bool = True) -> Path:
    """Return the per-robot base directory path (data_dir/hardwares/robots/<id>).

    Args:
        robot_id: Persisted robot id
        create: Whether to ensure the directory exists
    """
    robot_dir = get_robots_base_dir(create=True) / robot_id
    if create:
        robot_dir.mkdir(parents=True, exist_ok=True)
    return robot_dir


def get_robot_urdf_dir(robot_id: str, create: bool = True) -> Path:
    """Return the per-robot URDF directory path (data_dir/hardwares/robots/<id>/urdf).

    Args:
        robot_id: Persisted robot id
        create: Whether to ensure the directory exists
    """
    robot_dir = get_robot_base_dir(robot_id, create=True) / "urdf"
    if create:
        robot_dir.mkdir(parents=True, exist_ok=True)
    return robot_dir



# --------------------------- Robot Config Service ---------------------------


class RobotSpecService:
    """
    Service for loading robot specifications.

    Loads robot definitions from `robot_specs.json` and provides methods to
    access the definitions. The loaded specs are cached in memory.
    """

    def __init__(self, config_path: Path | None = None) -> None:
        """
        Initialize robot spec service.

        Args:
            config_path: Optional path to `robot_specs.json`. If not provided, the
                         service will attempt to load from package resources via
                         `leropilot.utils.get_resources_dir()` or fallback to
                         `importlib.resources`.
        """
        self.config_path = config_path
        self._cached: list[RobotDefinition] | None = None

    def _load_config(self) -> list[RobotDefinition]:
        """Load robot specifications from JSON and cache the result."""
        try:
            data = None
            if self.config_path is not None:
                if self.config_path.exists():
                    with open(self.config_path, encoding="utf-8") as f:
                        data = json.load(f)
                else:
                    logger.warning(f"Robot specs not found at {self.config_path}")
            else:
                # Prefer configured resources dir when available
                try:
                    from leropilot.utils.paths import get_resources_dir

                    resources_dir = get_resources_dir()
                    spec_file = resources_dir / "robot_specs.json"
                    if spec_file.exists():
                        with open(spec_file, encoding="utf-8") as f:
                            data = json.load(f)
                    else:
                        # Fallback to package resource
                        resource_files = importlib.resources.files("leropilot.resources")
                        config_file = resource_files.joinpath("robot_specs.json")
                        with config_file.open("r", encoding="utf-8") as f:
                            data = json.load(f)
                except Exception:
                    # Final fallback: importlib.resources directly
                    resource_files = importlib.resources.files("leropilot.resources")
                    config_file = resource_files.joinpath("robot_specs.json")
                    with config_file.open("r", encoding="utf-8") as f:
                        data = json.load(f)

            robots_data = (data or {}).get("robots", [])
            robots = [RobotDefinition(**r) for r in robots_data]
            # Sort robots by display_name for consistent UI presentation
            def _get_sort_key(r: RobotDefinition) -> str:
                if isinstance(r.display_name, str):
                    return r.display_name
                # Use "en" as fallback for sorting if it's a dict
                return r.display_name.get("en") or (list(r.display_name.values())[0] if r.display_name else "")

            robots.sort(key=_get_sort_key)
            logger.info(f"Loaded {len(robots)} robot specifications")
            return robots
        except Exception as e:
            logger.error(f"Failed to load robot specifications: {e}")
            return []

    def get_all_definitions(self) -> list[RobotDefinition]:
        """Return all robot definitions, loading and caching them if necessary."""
        if self._cached is None:
            self._cached = self._load_config()
        return self._cached

    def get_robot_definition(self, robot_id: str) -> RobotDefinition | None:
        """
        Get robot definition by ID.

        Args:
            robot_id: Robot ID to look up

        Returns:
            RobotDefinition if found, None otherwise
        """
        for robot in self.get_all_definitions():
            if robot.id == robot_id:
                return robot
        return None


# --------------------------- Robot Manager ---------------------------


class RobotManager:
    """Manage persisted robots list.json.

    Responsible for loading, caching, saving and removing robot entries from
    the centralized list file stored under AppConfig.paths.data_dir/hardwares/robots/list.json.
    """

    _instance: Optional["RobotManager"] = None
    _lock = threading.Lock()

    def __new__(cls) -> "RobotManager":
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self) -> None:
        if not hasattr(self, "_initialized"):
            self._robots: dict[str, Robot] = {}
            self._lock = threading.RLock()
            self._initialized = True
            self._load_robots()
            logger.info("RobotManager initialized")

    def _load_robots(self) -> None:
        try:
            list_path = get_robot_list_path()
            if list_path.exists():
                with open(list_path, encoding="utf-8") as f:
                    data = json.load(f)
                for r in data.get("robots", []):
                    try:
                        # Normalize persisted data before constructing Robot objects:
                        # - Ensure runtime-only fields like `interface` are present (may be null) so
                        #   pydantic validation does not fail when loading old files that omitted them.
                        # - Normalize custom protection keys that may have been serialized with commas.
                        import copy
                        r_copy = copy.deepcopy(r)

                        # Motor bus connections: ensure `interface` key exists (set to None if missing)
                        mbc = r_copy.get("motor_bus_connections")
                        if isinstance(mbc, dict):
                            for _k, v in mbc.items():
                                if isinstance(v, dict) and "interface" not in v:
                                    # Keep explicit null rather than omitting the field
                                    v["interface"] = None

                        # Custom protection settings: older files may have used comma-separated keys
                        # and earlier write paths may have left string keys in various formats.
                        # Convert keys into canonical tuple form so pydantic validation accepts them
                        cps = r_copy.get("custom_protection_settings")
                        if isinstance(cps, dict):
                            new_cps: dict = {}
                            for k, val in cps.items():
                                # If the key is a string, split on either ',' or ':' and build a tuple
                                if isinstance(k, str):
                                    sep = "," if ("," in k and ":" not in k) else ":"
                                    parts = [p.strip() for p in k.split(sep) if p.strip()]
                                    if len(parts) >= 2:
                                        brand = parts[0]
                                        model = parts[1]
                                        variant = parts[2] if len(parts) >= 3 else None
                                        key_tuple = (brand, model, variant)
                                    else:
                                        # Fallback: keep raw string as single-element tuple (will likely raise later)
                                        key_tuple = (k,)
                                    new_cps[key_tuple] = val
                                elif isinstance(k, (list, tuple)):
                                    # Normalize list/tuple keys to (brand, model, variant|None)
                                    if len(k) >= 2:
                                        brand = str(k[0])
                                        model = str(k[1])
                                        variant = str(k[2]) if len(k) >= 3 else None
                                        key_tuple = (brand, model, variant)
                                    else:
                                        key_tuple = tuple(k)
                                    new_cps[key_tuple] = val
                                else:
                                    # Keep as-is for unknown key types
                                    new_cps[k] = val
                            r_copy["custom_protection_settings"] = new_cps

                        robot = Robot(**r_copy)
                        self._normalize_robot(robot)
                        self._apply_protection_defaults(robot, prune=False)

                        # Loaded robots are offline by default until seen
                        robot.status = DeviceStatus.OFFLINE
                        self._robots[robot.id] = robot
                    except Exception as e:
                        logger.warning(f"Error loading robot {r.get('id')}: {e}")
                logger.info(f"Loaded {len(self._robots)} robots from {list_path}")
            else:
                logger.info("No robot list found; starting with empty list")
        except Exception as e:
            logger.error(f"Error loading robot list: {e}")

    def list_robots(self, refresh_status: bool = False) -> list[Robot]:
        """Return all robots currently managed."""
        with self._lock:
            if refresh_status:
                self.refresh_status()
            return sorted(self._robots.values(), key=lambda r: r.name)

    def get_robot(self, robot_id: str, refresh_status: bool = False) -> Robot | None:
        with self._lock:
            if refresh_status:
                self.refresh_status(robot_id=robot_id)
            robot = self._robots.get(robot_id)
            return robot

    def get_robot_motor_models_info(self, robot_id: str) -> list[MotorModelInfo]:
        """Return a deduplicated list of MotorModelInfo entries for the robot's
        definition-based motor list.

        Args:
            robot_id: persisted robot id

        Returns:
            List of `MotorModelInfo` instances matching the robot definition.

        Raises:
            ValueError: if the robot ID does not exist.
        """
        with self._lock:
            robot = self._robots.get(robot_id)
            if robot is None:
                raise ResourceNotFoundError("hardware.robot_device.not_found", id=robot_id)

            defn = robot.definition
            # Robot.definition must be a RobotDefinition object; string ids are not supported at runtime
            if isinstance(defn, str):
                raise ValueError("Robot.definition must be a RobotDefinition, not a string")

            return self._get_robot_motor_models_info_internal(robot)

    def _get_robot_motor_models_info_internal(self, robot: Robot) -> list[MotorModelInfo]:
        """Internal helper to get motor models info for a Robot instance."""
        # Use MotorUtil for table lookups
        try:
            from leropilot.services.hardware.motor_drivers.base import MotorUtil
        except Exception:
            MotorUtil = None  # type: ignore

        defn = robot.definition
        if not defn or isinstance(defn, str) or not getattr(defn, "motor_buses", None):
            return []

        seen: set[tuple[str, str, str | None]] = set()
        results: list[MotorModelInfo] = []

        for mb_def in defn.motor_buses.values() if isinstance(defn.motor_buses, dict) else defn.motor_buses:
            for rmd in mb_def.motors.values() if isinstance(mb_def.motors, dict) else mb_def.motors:
                brand = getattr(rmd, "brand", None)
                model = getattr(rmd, "model", None)
                variant = getattr(rmd, "variant", None)
                if not model:
                    continue
                mi = None
                if MotorUtil is not None:
                    mi = MotorUtil.find_motor(brand or "", model, variant)
                if mi is None:
                    # not resolved via tables; skip
                    continue
                brand_val = mi.brand.value if mi.brand is not None else ""
                key = (
                    str(brand_val).lower(),
                    (mi.model or "").lower(),
                    (mi.variant or None),
                )
                if key in seen:
                    continue
                seen.add(key)
                results.append(mi)

        return results

    def _apply_protection_defaults(self, robot: Robot, prune: bool = False) -> None:
        """Merge or prune default protection settings.

        Args:
           prune: If True, remove settings that match defaults.
                  If False (default), add default settings where missing.
        """
        # Get defaults
        models_info = self._get_robot_motor_models_info_internal(robot)

        # Build defaults map: (brand, model, variant) -> {type: value}
        defaults_map: dict[tuple[str, str, str | None], dict[str, float]] = {}
        for mi in models_info:
            brand_val = str(mi.brand.value).lower() if mi.brand else ""
            model_val = str(mi.model).lower() if mi.model else ""
            # Note: Robot keys use (brand, model, variant) where brand/model are strings
            key = (brand_val, model_val, mi.variant)
            defaults_map[key] = {k: v.value for k, v in mi.limits.items()}

        current_settings = robot.custom_protection_settings

        if prune:
            # Remove defaults
            keys_to_remove = []
            for key, limits in current_settings.items():
                # Normalize key for lookup (ensure brand/model are strictly strings)
                lookup_key = (str(key[0]).lower(), str(key[1]).lower(), key[2])

                if lookup_key not in defaults_map:
                    continue

                default_limits = defaults_map[lookup_key]
                new_limits = []
                for limit in limits:
                    # Check if matches default
                    if limit.type in default_limits and default_limits[limit.type] == limit.value:
                        continue  # Prune
                    new_limits.append(limit)

                if not new_limits:
                    keys_to_remove.append(key)
                else:
                    current_settings[key] = new_limits

            for k in keys_to_remove:
                del current_settings[k]

        else:
            # Expand defaults (Add missing)
            for key, default_limits in defaults_map.items():
                # Ensure key exists
                if key not in current_settings:
                    current_settings[key] = []

                existing_limits = {l.type: l.value for l in current_settings[key]}
                
                # Check if we have modified list object, if not, create one to ensure mutation works
                # (though accessing via dict usually gives reference)

                for type_name, val in default_limits.items():
                    if type_name not in existing_limits:
                        # Add default
                        current_settings[key].append(MotorLimit(type=type_name, value=val))


    def _normalize_robot(self, robot: Robot) -> None:
        """Resolve definition ID strings into full RobotDefinition objects."""
        if isinstance(robot.definition, str):
            spec = RobotSpecService()
            defn = spec.get_robot_definition(robot.definition)
            if defn is None:
                raise ResourceNotFoundError("hardware.robot_device.unknown_definition", id=robot.definition)
            robot.definition = defn

    def add_robot(self, robot: Robot) -> Robot:
        with self._lock:
            if not robot.id or robot.id.strip() == "":
                import uuid

                robot.id = uuid.uuid4().hex
            
            self._normalize_robot(robot)

            if robot.id in self._robots:
                raise ResourceConflictError("hardware.robot_device.conflict_id", id=robot.id)

            self.verify_robot(robot)
            self._apply_protection_defaults(robot, prune=True)
            self._robots[robot.id] = robot
            self._save_robots()
            self._apply_protection_defaults(robot, prune=False)
            logger.info(f"Added robot {robot.id}: {robot.name}")
            return robot

    def update_robot(self, robot_id: str, verify: bool = True, **kwargs: object) -> Robot | None:
        """Update an existing robot.

        Args:
            robot_id: Persisted robot id to update
            verify: When True, run `verify_robot` on the updated robot before persisting; on
                    verification failure a `RobotVerificationError` will be raised and the
                    persisted state will not be changed.
            **kwargs: Attributes to set on the Robot instance.

        Returns:
            The updated `Robot` on success, or `None` when the robot does not exist.
        """
        with self._lock:
            if robot_id not in self._robots:
                raise ResourceNotFoundError("hardware.robot_device.not_found", id=robot_id)
            # Merge provided updates into a fresh validated Robot instance so
            # that incoming dicts (e.g., motor_bus_connections) are validated and
            # converted into the proper model types (RobotMotorBusConnection, etc.).
            current = self._robots[robot_id]
            merged = current.model_dump()
            for k, v in kwargs.items():
                merged[k] = v

            # Normalize custom_protection_settings keys from legacy formats if present
            cps = merged.get("custom_protection_settings")
            if isinstance(cps, dict):
                new_cps: dict = {}
                for k, val in cps.items():
                    if isinstance(k, str):
                        # split on either ',' or ':' and build a tuple key (brand, model, variant|None)
                        sep = "," if ("," in k and ":" not in k) else ":"
                        parts = [p.strip() for p in k.split(sep) if p.strip()]
                        if len(parts) >= 2:
                            brand = parts[0]
                            model = parts[1]
                            variant = parts[2] if len(parts) >= 3 else None
                            key_tuple = (brand, model, variant)
                        else:
                            # fallback: keep raw string as single-element tuple
                            key_tuple = (k,)
                        new_cps[key_tuple] = val
                    elif isinstance(k, (list, tuple)):
                        if len(k) >= 2:
                            brand = str(k[0])
                            model = str(k[1])
                            variant = str(k[2]) if len(k) >= 3 else None
                            key_tuple = (brand, model, variant)
                        else:
                            key_tuple = tuple(k)
                        new_cps[key_tuple] = val
                    else:
                        new_cps[k] = val
                merged["custom_protection_settings"] = new_cps

            # Construct a new Robot object (runs pydantic validation & normalization)
            robot = Robot(**merged)
            self._normalize_robot(robot)

            # If requested, verify hardware now; verification errors propagate so callers
            # can decide how to map them (e.g., HTTP 409 in router layer).
            if verify:
                # verify_robot raises ResourceConflictError/ValidationError on failure
                self.verify_robot(robot)

            # Persist only when verification (if requested) passed
            self._apply_protection_defaults(robot, prune=True)
            self._robots[robot_id] = robot
            self._save_robots()
            self._apply_protection_defaults(robot, prune=False)
            logger.info(f"Updated robot {robot_id}")
            return robot

    def remove_robot(self, robot_id: str) -> bool:
        with self._lock:
            if robot_id not in self._robots:
                raise ResourceNotFoundError("hardware.robot_device.not_found", id=robot_id)
            del self._robots[robot_id]
            self._save_robots()
            logger.info(f"Removed robot {robot_id}")
            return True

    def _save_robots(self) -> None:
        with self._lock:
            try:
                list_path = get_robot_list_path()
                data: dict[str, object] = {"version": "1.0", "robots": []}
                robots_list = cast(list, data["robots"])
                # Exclude transient robots from save
                for robot in self._robots.values():
                    if robot.is_transient:
                        continue
                    robot_dict = robot.model_dump(mode="json", exclude_none=True)

                    # Remove runtime-only fields from motor_bus_connections (do not persist interface values)
                    mbc = robot_dict.get("motor_bus_connections")
                    if isinstance(mbc, dict):
                        for conn in mbc.values():
                            if isinstance(conn, dict) and "interface" in conn:
                                conn.pop("interface", None)

                    # Normalize definition: if definition is a RobotDefinition and matches a known spec, store its id
                    from leropilot.services.hardware.robots import RobotSpecService

                    spec = RobotSpecService()
                    def_val = robot.definition
                    if isinstance(def_val, RobotDefinition):
                        # If this definition matches a known spec, store its id for compactness
                        try:
                            if spec.get_robot_definition(def_val.id):
                                robot_dict["definition"] = def_val.id
                            else:
                                # Serialize definition to a dict, converting motors maps to lists for file storage
                                def_dump = def_val.model_dump(mode="json", exclude_none=True)
                                import copy
                                def_copy = copy.deepcopy(def_dump)
                                for mb in def_copy.get("motor_buses", {}).values():
                                    motors = mb.get("motors")
                                    if isinstance(motors, dict):
                                        new_list = []
                                        for name, m in motors.items():
                                            if isinstance(m, dict):
                                                m2 = dict(m)
                                                m2.setdefault("name", name)
                                                new_list.append(m2)
                                            else:
                                                new_list.append(m)
                                        mb["motors"] = new_list
                                robot_dict["definition"] = def_copy
                        except Exception:
                            # Fallback: attempt to dump model
                            try:
                                robot_dict["definition"] = def_val.model_dump(mode="json", exclude_none=True)
                            except Exception:
                                robot_dict["definition"] = str(def_val)
                    else:
                        robot_dict["definition"] = def_val

                    robots_list.append(robot_dict)

                with open(list_path, "w", encoding="utf-8") as f:
                    json.dump(data, f, indent=2, ensure_ascii=False)
                logger.debug("Saved %d robots to %s", len(robots_list), list_path)
                logger.debug(f"Saved {len(robots_list)} robots to {list_path}")
            except Exception as e:
                logger.error(f"Error saving robots: {e}")

    def _discover_motor_buses(
        self, filters: list[tuple[str, int | None]] | None = None
    ) -> list[tuple["MotorBus", "str | None", "str | None"]]:
        """Discover motor bus instances that have motors attached.

        The returned ``bus`` objects are lightweight proxies (disconnected) that
        expose `interface`, `baud_rate` and `motors` attributes. Implementations
        should not assume the underlying hardware connection remains open.

        Args:
            filters: Optional list of (motorbus_type, baudrate) pairs to restrict discovery.
                     If provided, only the specified motorbus types / baudrates will be tried.
        Returns:
            List[tuple]: list of tuples (bus_proxy, serial_number, manufacturer) for each
                         motorbus where motors were successfully found. `serial_number` and
                         `manufacturer` may be None when not available.
        """
        from leropilot.services.hardware.motor_buses.motor_bus import MotorBus

        adapter = PlatformAdapter()

        # Build allowed map from filters: class -> set(baudrates)
        allowed: dict[type, set[int] | None] = {}
        if filters:
            for t, baud in filters:
                try:
                    cls = MotorBus.resolve_bus_class(t)
                except Exception:
                    logger.debug(f"Unknown motorbus type in filters: {t}")
                    continue
                # Ensure an entry exists and is a set before adding
                if cls not in allowed:
                    allowed[cls] = set()
                if baud is not None:
                    vals = allowed.get(cls)
                    if vals is None:
                        allowed[cls] = set()
                        vals = allowed[cls]
                    # mypy can't always infer that vals is a set; assert its type
                    if isinstance(vals, set):
                        vals.add(int(baud))
                    else:
                        allowed[cls] = {int(baud)}
                else:
                    allowed[cls] = None

        results: list = []

        # Helper to check whether we should try a given class (and to get allowed baudrates)
        def _get_allowed_baudrates_for(cls: type) -> list[int] | None:
            # `cls` is assumed to be a MotorBus class with `supported_baudrates`.
            # Use a runtime Any cast to help mypy understand it has the attribute.
            if not filters:
                return (cast(Any, cls)).supported_baudrates()  # type: ignore[return-value]
            if cls not in allowed:
                return None
            vals = allowed[cls]
            if vals is None or len(vals) == 0:
                return (cast(Any, cls)).supported_baudrates()  # type: ignore[return-value]
            # preserve class ordering but filter to allowed set
            return [b for b in (cast(Any, cls)).supported_baudrates() if b in vals]

        # Discover serial ports and try serial-type motor buses unless filters exclude them
        serial_ports = adapter.discover_serial_ports()
        # If filters provided and none of the filtered classes are serial types, skip serial
        if filters:
            serial_classes = set(MotorBus.serial_types())
            if not any(cls in serial_classes for cls in allowed.keys()):
                serial_ports = []

        for port in serial_ports:
            port_name = port.port
            # collect metadata for returned tuple
            serial_number = port.serial_number
            manufacturer = port.manufacturer

            for cls in MotorBus.serial_types():
                baud_candidates = _get_allowed_baudrates_for(cls)
                if baud_candidates is None:
                    continue
                found = False
                for baud in baud_candidates:
                    bus = None
                    try:
                        bus = MotorBus.create(cls, port_name, baud)
                        if not bus.connect():
                            try:
                                bus.disconnect()
                            except Exception:
                                pass
                            continue

                        motors = bus.scan_motors()
                        if motors:
                            logger.info(f"Found motors on {port_name} using {cls.__name__} @ {baud}")
                            # Snapshot motors and disconnect to avoid leaving hardware open
                            motors_snapshot = dict(getattr(bus, "motors", {}))
                            try:
                                bus.disconnect()
                            except Exception:
                                pass

                            # Create lightweight proxy class so callers can inspect .motors, .interface, .baud_rate
                            BusProxy = type(cls.__name__, (), {})
                            bus_proxy = BusProxy()
                            bus_proxy.interface = port_name
                            bus_proxy.baud_rate = baud
                            bus_proxy.motors = motors_snapshot

                            results.append((bus_proxy, serial_number, manufacturer))
                            found = True
                            break
                        else:
                            try:
                                bus.disconnect()
                            except Exception:
                                pass
                    except Exception as e:
                        logger.debug(f"Error probing {cls} on {port_name} @ {baud}: {e}")
                        if bus is not None:
                            try:
                                bus.disconnect()
                            except Exception:
                                pass
                if found:
                    # Do not try other serial motorbus types for this port if one succeeded
                    break

        # Discover CAN interfaces and try CAN-type motor buses unless filters exclude them
        can_interfaces = adapter.discover_can_interfaces()
        if filters:
            can_classes = set(MotorBus.can_types())
            if not any(cls in can_classes for cls in allowed.keys()):
                can_interfaces = []

        for interface in can_interfaces:
            if_name = interface.interface
            serial_number = interface.serial_number
            manufacturer = interface.manufacturer

            for cls in MotorBus.can_types():
                bitrate_candidates = _get_allowed_baudrates_for(cls)
                if bitrate_candidates is None:
                    continue
                found = False
                for br in bitrate_candidates:
                    bus = None
                    try:
                        bus = MotorBus.create(cls, if_name, br)
                        if not bus.connect():
                            try:
                                bus.disconnect()
                            except Exception:
                                pass
                            continue
                        motors = bus.scan_motors()
                        if motors:
                            logger.info(f"Found motors on {if_name} using {cls.__name__} @ {br}")
                            motors_snapshot = dict(getattr(bus, "motors", {}))
                            try:
                                bus.disconnect()
                            except Exception:
                                pass

                            BusProxy = type(cls.__name__, (), {})
                            bus_proxy = BusProxy()
                            bus_proxy.interface = if_name
                            bus_proxy.baud_rate = br
                            bus_proxy.motors = motors_snapshot

                            results.append((bus_proxy, serial_number, manufacturer))
                            found = True
                            break
                        else:
                            try:
                                bus.disconnect()
                            except Exception:
                                pass
                    except Exception as e:
                        logger.debug(f"Error probing {cls} on {if_name} @ {br}: {e}")
                        if bus is not None:
                            try:
                                bus.disconnect()
                            except Exception:
                                pass
                if found:
                    break

        return results

    def get_pending_devices(self, lang: str = "en") -> list[Robot]:
        """Return a list of `Robot` objects representing motorbuses with motors attached.

        Converts each motorbus tuple returned by `_discover_motor_buses()` into a
        `Robot` object following the rules provided by the caller:
        - `id`: a generated UUID (persisted id) — serial number is stored on the connection
        - `name`: f"Unknown device on {motorbus.interface}" (localized)
        - `status`: DeviceStatus.AVAILABLE
        - `manufacturer`: None
        - `labels`: empty dict
        - `created_at`: datetime.now()
        - `is_transient`: True when serial number is missing
        - `calibration_settings`, `custom_protection_settings`: empty dicts
        - `motor_bus_connections`: {"motorbus": MotorBusConnection(...)}
        - `definition`: RobotDefinition with id="", display_name="Custom Robot Device",
          `description` aggregated from motor variants/models, and a single
          MotorBusDefinition under key "motorbus" containing per-motor entries
        """
        from datetime import datetime

        pending: list[Robot] = []
        results = self._discover_motor_buses()
        i18n = get_i18n_service()

        for bus, serial_number, _manufacturer in results:
            # Use a random UUID as the persisted robot id; serial is captured on the connection
            from uuid import uuid4

            robot_id = uuid4().hex
            
            # Localized device name
            name = i18n.translate(
                "hardware.robot_device.unknown_device_on",
                lang=lang,
                port=bus.interface
            ) or f"Unknown device on {bus.interface}"

            status = DeviceStatus.AVAILABLE
            labels: dict = {}
            created_at = datetime.now()
            is_transient = not bool(serial_number)

            # MotorBus connection entry (serial_number may be None)
            baud_raw = getattr(bus, "baud_rate", None)
            baud_val = int(baud_raw) if baud_raw is not None else 0
            conn = RobotMotorBusConnection(
                motor_bus_type=bus.__class__.__name__,
                interface=bus.interface,
                baudrate=baud_val,
                serial_number=serial_number,
            )
            motor_bus_connections = {"motorbus": conn}

            # Build motor definitions (dict keyed by logical name) and canonical type counts for description
            motor_defs: dict[str, RobotMotorDefinition] = {}
            type_counts: dict[str, int] = {}
            idx = 1
            for motor_key, entry in bus.motors.items():
                # entry is (driver, MotorModelInfo|None)
                # type: ignore[assignment]
                _, minfo = entry  # type: ignore[assignment]
                name_idx = str(idx)
                idx += 1
                if minfo is not None and minfo.brand is not None:
                    brand = str(minfo.brand.value)
                else:
                    brand = minfo.model if minfo else ""

                model = minfo.model if (minfo and getattr(minfo, "model", None)) else ""
                variant = minfo.variant if (minfo and getattr(minfo, "variant", None)) else None

                motor_def = RobotMotorDefinition(
                    name=name_idx,
                    id=motor_key,
                    brand=str(brand),
                    model=str(model),
                    variant=variant,
                    need_calibration=True,
                    drive_mode=0,
                )
                motor_defs[name_idx] = motor_def

                # Canonical type key for grouping (variant > model > unknown)
                typ_key = variant or model or "unknown"
                type_counts[typ_key] = type_counts.get(typ_key, 0) + 1

            # Build localized description strings by applying per-language templates
            templates = i18n.get_block("hardware.robot_definition.motor_count_templates")
            descriptions: dict[str, str] = {}
            # For display_name, prefer what's defined in i18n block for custom_robot_device
            display_name_block = i18n.get_block("hardware.robot_definition.custom_robot_device")

            if templates:
                for lang, tmpl in templates.items():
                    parts = []
                    for typ_key, cnt in type_counts.items():
                        if typ_key == "unknown":
                            loc_type = i18n.translate("hardware.robot_device.unknown", lang=lang)
                        else:
                            loc_type = typ_key
                        try:
                            parts.append(tmpl.get("item", "{count} {type} motors").format(count=cnt, type=loc_type))
                        except Exception:
                            parts.append(f"{cnt} {loc_type}")
                    sep = tmpl.get("sep", ", ")
                    descriptions[lang] = sep.join(parts)

            # Construct MotorBusDefinition and RobotDefinition (localized display_name/description)
            mb_def = MotorBusDefinition(
                type=bus.__class__.__name__,
                motors=motor_defs,
                baud_rate=getattr(bus, "baud_rate", None),
                interface_type=None,
            )

            # Build display_name dict from i18n if available
            if display_name_block:
                display_name = {k: v for k, v in display_name_block.items() if isinstance(v, str)}
            else:
                display_name = "Custom Robot Device"

            rdef = RobotDefinition(
                id="",
                lerobot_name=None,
                display_name=display_name,
                description=descriptions,
                support_version_from=None,
                support_version_end=None,
                urdf=None,
                motor_buses={"motorbus": mb_def},
            )

            robot = Robot(
                id=robot_id,
                name=name,
                status=status,
                manufacturer=None,
                labels=labels,
                created_at=created_at,
                is_transient=is_transient,
                definition=rdef,
                calibration_settings={},
                custom_protection_settings={},
                motor_bus_connections=motor_bus_connections,
            )

            pending.append(robot)

        return pending

    def _motor_bus_verify(self, bus: "MotorBus", motorbus_def: MotorBusDefinition) -> bool:
        """Verify whether a MotorBus instance matches a given MotorBusDefinition.

        Checks performed:
          - bus class name equals motorbus_def.type
          - number of motors matches
          - for each motor in the definition, an entry exists on the bus with matching
            id, brand, model and (optionally) variant. If a definition's variant is None
            the variant is not compared.
        """
        try:
            # Type check on class name
            if bus.__class__.__name__ != motorbus_def.type:
                return False

            # Build definition dict keyed by the raw id values (coerce list ids to tuples for hashability)
            req_by_id: dict[object, RobotMotorDefinition] = {}
            # motorbus_def.motors is expected to be a dict[name -> RobotMotorDefinition]
            for req in motorbus_def.motors.values() if isinstance(motorbus_def.motors, dict) else motorbus_def.motors:
                # Use the motor definition's canonical key form (int or tuple).
                rid = getattr(req, "key", req.id)
                req_key = rid if not isinstance(rid, list) else tuple(rid)
                # Duplicate definition ids are ambiguous
                if req_key in req_by_id:
                    return False
                req_by_id[req_key] = req

            from typing import cast

            from leropilot.services.hardware.motor_drivers.base import BaseMotorDriver

            # Build bus dict keyed by the raw motor keys (coerce list keys to tuples)
            bus_by_id: dict[object, tuple[BaseMotorDriver[Any], MotorModelInfo | None]] = {}
            for k, entry in bus.motors.items():
                # Normalize list keys to tuples
                key_norm = tuple(k) if isinstance(k, list) else k
                if not entry:
                    return False
                driver, minfo = entry  # type: ignore[assignment]
                if minfo is None:
                    return False
                # Duplicate keys are ambiguous
                if key_norm in bus_by_id:
                    return False
                bus_by_id[key_norm] = cast(tuple[BaseMotorDriver[Any], MotorModelInfo | None], entry)

            # Counts must match
            if len(bus_by_id) != len(req_by_id):
                return False

            # Compare each required motor against discovered motor info using exact-key matching
            from typing import cast

            for rk, req in req_by_id.items():
                req_key = cast(int | tuple[int, int], rk)
                entry_val = bus_by_id.get(req_key)
                if entry_val is None:
                    return False
                driver, minfo = cast(tuple[BaseMotorDriver[Any], MotorModelInfo | None], entry_val)
                if minfo is None:
                    return False

                # Brand check (case-insensitive) — discovery must provide brand and it
                # must match the requirement. Compare using enum .value for clarity.
                if str(getattr(minfo, "brand").value).lower() != str(req.brand).lower():
                    return False

                # Model check (case-insensitive exact)
                if (getattr(minfo, "model", "") or "").lower() != str(req.model).lower():
                    return False

                # Variant check only when requirement specifies one
                if req.variant is not None:
                    if (getattr(minfo, "variant", "") or "").lower() != str(req.variant).lower():
                        return False

            return True
        except Exception:
            return False

    def _check_robot_status(
        self, robot: Robot, discovered: list[tuple["MotorBus", "str | None", "str | None"]]
    ) -> tuple[DeviceStatus, bool]:
        """Compare a persisted `robot` against `discovered` motorbuses and return
        the computed DeviceStatus and a boolean indicating whether the robot should
        be removed (transient and offline).

        Returns:
            (status, should_remove)
        """
        try:
            all_connections_ok = True
            any_mismatch = False

            # If robot has no motor_bus_connections, consider it offline/invalid
            if not robot.motor_bus_connections:
                return DeviceStatus.OFFLINE, robot.is_transient

            # For each connection, try to find a matching discovered bus
            for conn_key, conn in (robot.motor_bus_connections or {}).items():
                conn_found = False
                matched_bus = None
                for bus, serial_num, _mf in discovered:
                    # If conn has serial_number, prefer matching by serial
                    if conn.serial_number:
                        if conn.serial_number == serial_num:
                            conn_found = True
                            matched_bus = bus
                            conn.interface = getattr(bus, "interface", None)
                            break
                    else:
                        # Fall back to matching by interface (runtime info)
                        if conn.interface and getattr(bus, "interface", None) == conn.interface:
                            conn_found = True
                            matched_bus = bus
                            conn.interface = getattr(bus, "interface", None)

                if not conn_found:
                    # Could not find required motorbus -> offline
                    all_connections_ok = False
                    conn.interface = None
                    break

                # If we have a motorbus definition for this connection, verify it
                mb_def = None
                defn = robot.definition
                if isinstance(defn, str):
                    spec = RobotSpecService()
                    defn = spec.get_robot_definition(defn)
                    if defn is None:
                        all_connections_ok = False
                        break

                if defn and getattr(defn, "motor_buses", None):
                    try:
                        mb_def = defn.motor_buses.get(conn_key)
                    except Exception:
                        mb_def = None

                if mb_def is not None:
                    assert matched_bus is not None
                    ok = self._motor_bus_verify(matched_bus, mb_def)
                    if not ok:
                        any_mismatch = True

            # Apply status logic (same semantics as previous inlined code)
            if not all_connections_ok:
                return DeviceStatus.OFFLINE, robot.is_transient
            if any_mismatch:
                return DeviceStatus.INVALID, False
            return DeviceStatus.AVAILABLE, False
        except Exception:
            # On unexpected error, degrade to OFFLINE and keep robot if not transient
            return DeviceStatus.OFFLINE, robot.is_transient

    def verify_robot(self, robot: Robot) -> bool:
        """Verify a persisted `robot` against the actual motorbuses present.

        Constructs MotorBus objects for each `RobotMotorBusConnection` in
        `robot.motor_bus_connections`, runs `scan_motors()` on each bus to
        discover attached motors, and then delegates to `_check_robot_status`
        to compute the overall status.

        Raises:
            ResourceConflictError: when verification fails resulting in OFFLINE or INVALID status.
            ValidationError: when a required interface is missing or when the motorbus type cannot be resolved.

        Returns:
            True on successful verification (AVAILABLE).
        """
        from leropilot.services.hardware.motor_buses.motor_bus import MotorBus

        if not robot.motor_bus_connections:
            raise ValueError("Robot has no motor bus connections to verify")

        discovered: list[tuple[MotorBus, str | None, str | None]] = []
        buses_to_close: list[MotorBus] = []

        try:
            for conn_key, conn in (robot.motor_bus_connections or {}).items():
                # Interface must be present to construct the runtime motorbus
                if not conn.interface:
                    raise ValidationError("hardware.robot_device.missing_interface", id=conn_key)

                # Resolve bus class
                try:
                    cls = MotorBus.resolve_bus_class(conn.motor_bus_type)
                except Exception as e:
                    raise ValidationError("hardware.robot_device.unknown_bus_type", bus_type=conn.motor_bus_type) from e

                # Create and probe the motorbus
                try:
                    bus = MotorBus.create(cls, conn.interface, conn.baudrate or 0)
                    if not bus.connect():
                        try:
                            bus.disconnect()
                        except Exception:
                            pass
                        raise ValidationError("hardware.robot_device.connect_failed", interface=conn.interface)

                    buses_to_close.append(bus)
                    # scan_motors should populate bus.motors
                    bus.scan_motors()
                    discovered.append((bus, conn.serial_number, None))
                except ValueError:
                    # pass through ValueError for better user messages
                    raise
                except Exception as e:
                    try:
                        bus.disconnect()
                    except Exception:
                        pass
                    raise RuntimeError(f"Error probing motorbus '{conn_key}': {e}") from e

            # Use the helper to check computed status
            status, _should_remove = self._check_robot_status(robot, discovered)

            if status == DeviceStatus.OFFLINE:
                raise ResourceConflictError("hardware.robot_device.offline")
            if status == DeviceStatus.INVALID:
                raise ResourceConflictError("hardware.robot_device.invalid_mismatch")

            # AVAILABLE -> verification passed
            return True
        finally:
            # Ensure buses are disconnected
            for b in buses_to_close:
                try:
                    b.disconnect()
                except Exception:
                    pass

    def refresh_status(self, robot_id: str | None = None) -> list[Robot] | Robot | None:
        """Refresh online/status state for a robot or all robots.

        Args:
            robot_id: Optional robot id to refresh (otherwise refresh all)

        Returns:
            If robot_id is None, returns list[Robot] of current robots after refresh.
            If robot_id is provided, returns the Robot instance after refresh, or
            None if the robot was transient and removed during refresh.
        """
        # Determine subset of robots to process
        to_process: list[tuple[str, Robot]] = []
        if robot_id is not None:
            r = self._robots.get(robot_id)
            if r is None:
                return None
            to_process = [(robot_id, r)]
        else:
            to_process = list(self._robots.items())

        # Aggregate filters (motorbus type, baudrate) from robots we will inspect
        filters: list[tuple[str, int | None]] = []
        for _, robot in to_process:
            defn = robot.definition
            if isinstance(defn, str):
                raise ValueError("Robot.definition must be a RobotDefinition, not a string")
            if not defn or not getattr(defn, "motor_buses", None):
                continue
            for key, _conn in (robot.motor_bus_connections or {}).items():
                mb = None
                try:
                    mb = defn.motor_buses.get(key)
                except Exception:
                    mb = None
                if mb is None:
                    continue
                filters.append((mb.type, mb.baud_rate or 0))

        # Discover available motorbuses (restrict by filters for efficiency)
        discovered = self._discover_motor_buses(filters if filters else None)

        # Map discovered (bus, serial, manufacturer) into lists for matching
        # We will iterate robots and try to match each of their connections
        removed_ids: list[str] = []
        for rid, robot in to_process:
            # Use helper to check robot status against discovered motorbuses
            new_status, should_remove = self._check_robot_status(robot, discovered)

            if new_status == DeviceStatus.OFFLINE and should_remove:
                # Robot is transient and offline -> remove
                removed_ids.append(rid)
            else:
                robot.status = new_status

        # Note: discovered buses were proxies (disconnected) created by _discover_motor_buses

        # Remove transient robots that are offline
        for rid in removed_ids:
            try:
                del self._robots[rid]
            except Exception:
                pass

        # Return per robot or all
        if robot_id is None:
            return list(self._robots.values())
        else:
            return self._robots.get(robot_id)


# --------------------------- Calibration Service ---------------------------

class CalibrationService:
    """Manages motor calibration data persistence and retrieval"""

    def __init__(self) -> None:
        """Initialize calibration service"""
        logger.info("CalibrationService initialized")

    # NOTE: CalibrationService modifications will be performed later as requested.


# Robot URDF manager
class RobotUrdfManager:
    """Manager for robot URDF files and archives."""

    def __init__(self, robot_manager: RobotManager | None = None) -> None:
        self._robot_manager = robot_manager or get_robot_manager()

    def _get_urdf_file(self, robot_id: str) -> Path:
        """Internal helper returning the expected custom URDF file path for a robot.

        Note: this returns the canonical path where a custom URDF would be stored;
        it does not guarantee the file exists. Callers should check existence.
        """
        return get_robot_urdf_dir(robot_id) / "robot.urdf"

    def delete_custom_urdf(self, robot_id: str) -> None:
        """Delete a previously uploaded custom URDF and any related resource files.

        Raises:
            ValueError: if the robot does not exist.
            FileNotFoundError: if no custom URDF is present on disk.
            RuntimeError: for other failures during deletion.
        """
        robot = self._robot_manager.get_robot(robot_id)
        if robot is None:
            raise ValueError("Robot not found")
        urdf_file = self._get_urdf_file(robot_id)
        if not urdf_file.exists():
            raise FileNotFoundError("Custom URDF not found")

        # Remove the entire urdf directory tree for this robot
        urdf_dir = urdf_file.parent
        import shutil

        try:
            shutil.rmtree(urdf_dir)
            # If robot dir is empty after removal, remove it as well
            robot_dir = urdf_dir.parent
            try:
                if robot_dir.exists() and not any(robot_dir.iterdir()):
                    robot_dir.rmdir()
            except Exception:
                # Ignore failures to remove parent dir
                pass
        except Exception as e:
            raise RuntimeError(f"Failed to delete URDF: {e}") from e

    def upload_custom_urdf(self, robot_id: str, data: bytes) -> Path:
        import io
        import os
        import shutil
        import tarfile
        import tempfile
        import zipfile

        # Basic validation
        robot = self._robot_manager.get_robot(robot_id)
        if robot is None:
            raise ResourceNotFoundError("hardware.robot_device.not_found", id=robot_id)

        target_dir = get_robot_urdf_dir(robot_id, create=True)
        target_dir.mkdir(parents=True, exist_ok=True)

        def _validate_and_mark(urdf_file: Path) -> None:
            from leropilot.utils.urdf import validate_file

            result = validate_file(str(urdf_file))
            if not result.get("valid", False):
                raise ValueError({"error": "URDF validation failed", "details": result})

            # Validation passed; custom URDF file is present on disk (no flag required)

        if data.startswith(b"PK"):
            try:
                with zipfile.ZipFile(io.BytesIO(data)) as zf:
                    names = [n for n in zf.namelist() if not n.endswith("/")]
                    top_urdfs = [
                        n
                        for n in names
                        if os.path.basename(n).lower().endswith(".urdf") and ("/" not in n and "\\" not in n)
                    ]
                    if len(top_urdfs) != 1:
                        raise ValueError("Archive must contain exactly one top-level .urdf file")
                    with tempfile.TemporaryDirectory() as tmpd:
                        zf.extractall(tmpd)
                        for root, _dirs, files in os.walk(tmpd):
                            rel_root = os.path.relpath(root, tmpd)
                            dest_root = target_dir if rel_root == "." else target_dir / rel_root
                            dest_root.mkdir(parents=True, exist_ok=True)
                            for fname in files:
                                src = Path(root) / fname
                                dest = dest_root / fname
                                shutil.move(str(src), str(dest))

                        top_urdf_name = top_urdfs[0]
                        src_urdf = target_dir / os.path.basename(top_urdf_name)
                        dest_urdf = target_dir / "robot.urdf"
                        if not src_urdf.exists():
                            raise ValueError("Top-level URDF not found after extraction")
                        if src_urdf.name != "robot.urdf":
                            try:
                                dest_urdf.unlink(missing_ok=True)
                            except Exception:
                                pass
                            shutil.move(str(src_urdf), str(dest_urdf))

                        _validate_and_mark(dest_urdf)
                        return dest_urdf
            except ValueError:
                raise
            except Exception as e:
                raise ValueError(f"Failed to process ZIP archive: {e}") from e
        elif data[:2] == b"\x1f\x8b":
            try:
                with tempfile.TemporaryDirectory() as tmpd:
                    with tarfile.open(fileobj=io.BytesIO(data), mode="r:gz") as tf:
                        members = [m for m in tf.getmembers() if m.isfile()]
                        top_urdfs = [
                            m.name
                            for m in members
                            if os.path.basename(m.name).lower().endswith(".urdf")
                            and ("/" not in m.name and "\\" not in m.name)
                        ]
                        if len(top_urdfs) != 1:
                            raise ValueError("Archive must contain exactly one top-level .urdf file")
                        tf.extractall(tmpd)
                        for root, _dirs, files in os.walk(tmpd):
                            rel_root = os.path.relpath(root, tmpd)
                            dest_root = target_dir if rel_root == "." else target_dir / rel_root
                            dest_root.mkdir(parents=True, exist_ok=True)
                            for fname in files:
                                src = Path(root) / fname
                                dest = dest_root / fname
                                shutil.move(str(src), str(dest))

                                src_urdf = target_dir / os.path.basename(top_urdfs[0])
                        dest_urdf = target_dir / "robot.urdf"
                        if not src_urdf.exists():
                            raise ValueError("Top-level URDF not found after extraction")
                        if src_urdf.name != "robot.urdf":
                            try:
                                dest_urdf.unlink(missing_ok=True)
                            except Exception:
                                pass
                            shutil.move(str(src_urdf), str(dest_urdf))

                        _validate_and_mark(dest_urdf)
                        return dest_urdf
            except ValueError:
                raise
            except Exception as e:
                raise ValueError(f"Failed to process tar.gz archive: {e}") from e
        else:
            try:
                dest_urdf = target_dir / "robot.urdf"
                with open(dest_urdf, "wb") as fh:
                    fh.write(data)
                _validate_and_mark(dest_urdf)
                return dest_urdf
            except Exception as e:
                raise ValueError(f"Failed to save URDF: {e}") from e

    def get_robot_urdf_resource(self, robot_id: str, path: str = "robot.urdf") -> bytes | None:
        """Return the bytes content of a URDF file for a robot.

        Args:
            robot_id: persisted robot id
            path: resource path/filename to look up (defaults to "robot.urdf").

        Returns:
            `bytes` when a resource is found and read, or `None` when not found.

        Raises:
            ValueError: if the robot is not found.
        """
        # Local imports to avoid import cycles and keep module-level imports light
        from importlib.abc import Traversable
        from leropilot.utils.urdf import get_robot_resource

        robot = self._robot_manager.get_robot(robot_id)
        if robot is None:
            raise ValueError("Robot not found")

        # Check custom user-provided resources first
        urdf_dir = self._get_urdf_file(robot_id).parent
        user_file = urdf_dir / path
        if user_file.exists():
            try:
                return user_file.read_bytes()
            except Exception as e:
                raise RuntimeError(f"Failed to read custom URDF: {e}") from e

        # Resolve default via robot.definition.id (preferred over lerobot_name for resources)
        defn = robot.definition
        if isinstance(defn, str):
            raise ValueError("Robot.definition must be a RobotDefinition, not a string")
        # If there's no definition, there is no built-in URDF
        if not defn:
            return None
        
        # Use definition ID as the resource folder name
        resource = get_robot_resource(defn.id, path)
            
        if resource:
            # Use as_file to get a filesystem path to read from
            try:
                with importlib.resources.as_file(resource) as fp:
                    return fp.read_bytes()
            except Exception as e:
                raise RuntimeError(f"Failed to read packaged URDF: {e}") from e

        return None

# Convenience getters
_robot_manager: RobotManager | None = None
_manager_lock = threading.Lock()


def get_robot_manager() -> RobotManager:
    global _robot_manager
    with _manager_lock:
        if _robot_manager is None:
            _robot_manager = RobotManager()
        return _robot_manager


# Singleton accessor for URDF manager
_robot_urdf_manager: RobotUrdfManager | None = None
_urdf_lock = threading.Lock()


def get_robot_urdf_manager() -> RobotUrdfManager:
    global _robot_urdf_manager
    with _urdf_lock:
        if _robot_urdf_manager is None:
            _robot_urdf_manager = RobotUrdfManager()
        return _robot_urdf_manager
